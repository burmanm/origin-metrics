From 82407eee7ff76e9df6d36e3278d281dca77fac55 Mon Sep 17 00:00:00 2001
From: Michael Burman <yak@iki.fi>
Date: Thu, 14 Sep 2017 10:44:51 +0300
Subject: [PATCH 4/4] Instead of storing a struct in the memory, store only a
 hash of it. Also, fetch with descriptorTag from HWKMETRICS and not all the
 metric definitions for caching purposes

Cache all tenants

(cherry picked from commit 364dd317376473a6b732260f71ff9e17742c8202)
---
 metrics/sinks/hawkular/client.go      | 112 ++++++++++++++++++++++++++++------
 metrics/sinks/hawkular/driver.go      |  17 +++---
 metrics/sinks/hawkular/driver_test.go |  90 ++++++++++++++-------------
 metrics/sinks/hawkular/types.go       |   2 +-
 4 files changed, 148 insertions(+), 73 deletions(-)

diff --git a/metrics/sinks/hawkular/client.go b/metrics/sinks/hawkular/client.go
index f2246927..7e614671 100644
--- a/metrics/sinks/hawkular/client.go
+++ b/metrics/sinks/hawkular/client.go
@@ -15,10 +15,12 @@
 package hawkular
 
 import (
+	"bytes"
 	"fmt"
+	"hash/fnv"
 	"math"
-	"reflect"
 	"regexp"
+	"sort"
 	"strings"
 	"sync"
 	"time"
@@ -28,35 +30,101 @@ import (
 	"k8s.io/heapster/metrics/core"
 )
 
-// Fetches definitions from the server and checks that they're matching the descriptors
-func (h *hawkularSink) updateDefinitions(mt metrics.MetricType) error {
+// cacheDefinitions Fetches all known definitions from all tenants (all projects in Openshift)
+func (h *hawkularSink) cacheDefinitions() error {
+	tds, err := h.client.Tenants()
+	if err != nil {
+		return err
+	}
+
+	// TagsFiltering for definitions
+	tagsFilter := make(map[string]string, 1)
+	tagsFilter[descriptorTag] = "*"
+
 	m := make([]metrics.Modifier, len(h.modifiers), len(h.modifiers)+1)
 	copy(m, h.modifiers)
-	m = append(m, metrics.Filters(metrics.TypeFilter(mt)))
+	m = append(m, metrics.Filters(metrics.TagsFilter(tagsFilter)))
+
+	wG := &sync.WaitGroup{}
+
+	for _, td := range tds {
+		fetchModifiers := make([]metrics.Modifier, len(m), len(m)+1)
+		copy(fetchModifiers, m)
+		fetchModifiers = append(m, metrics.Tenant(td.ID))
 
+		wG.Add(1)
+		go func(m ...metrics.Modifier) {
+			err := h.updateDefinitions(fetchModifiers...)
+			if err != nil {
+				fmt.Println(err)
+			}
+			wG.Done()
+		}()
+
+		// Any missing fetches will be cached in the first datapoint store
+	}
+
+	wG.Wait()
+	glog.V(4).Infof("PreCaching completed, cached %d definitions\n", len(h.reg))
+
+	return nil
+}
+
+// Fetches definitions from the server and checks that they're matching the descriptors
+func (h *hawkularSink) updateDefinitions(m ...metrics.Modifier) error {
 	mds, err := h.client.Definitions(m...)
 	if err != nil {
 		return err
 	}
 
-	h.regLock.Lock()
-	defer h.regLock.Unlock()
-
 	for _, p := range mds {
-		// If no descriptorTag is found, this metric does not belong to Heapster
-		if mk, found := p.Tags[descriptorTag]; found {
-			if model, f := h.models[mk]; f && !h.recent(p, model) {
-				if err := h.client.UpdateTags(mt, p.ID, p.Tags, h.modifiers...); err != nil {
-					return err
-				}
+		if model, f := h.models[p.Tags[descriptorTag]]; f && !h.recent(p, model) {
+			if err := h.client.UpdateTags(p.Type, p.ID, p.Tags, h.modifiers...); err != nil {
+				return err
 			}
-			h.reg[p.ID] = p
 		}
+		h.regLock.Lock()
+		h.reg[p.ID] = hash(p)
+		h.regLock.Unlock()
 	}
 
 	return nil
 }
 
+func hash(md *metrics.MetricDefinition) uint64 {
+	h := fnv.New64a()
+
+	// Hash metricId first
+	// h.Write([]byte(tenant))
+	h.Write([]byte(md.Type))
+	h.Write([]byte(md.ID))
+
+	// Then tags to allow "recent" checking
+	var buffer bytes.Buffer
+
+	tagNames := make([]string, 0, len(md.Tags))
+	tagValues := make([]string, 0, len(md.Tags))
+
+	for k, v := range md.Tags {
+		tagNames = append(tagNames, k)
+		tagValues = append(tagValues, v)
+	}
+
+	sort.Strings(tagNames)
+	sort.Strings(tagValues)
+
+	for _, tn := range tagNames {
+		buffer.WriteString(tn)
+	}
+
+	for _, tv := range tagValues {
+		buffer.WriteString(tv)
+	}
+
+	buffer.WriteTo(h)
+	return h.Sum64()
+}
+
 // Checks that stored definition is up to date with the model
 func (h *hawkularSink) recent(live *metrics.MetricDefinition, model *metrics.MetricDefinition) bool {
 	recent := true
@@ -189,8 +257,9 @@ func (h *hawkularSink) createDefinitionFromModel(ms *core.MetricSet, metric core
 	return nil, fmt.Errorf("Could not find definition model with name %s", metric.Name)
 }
 
-func (h *hawkularSink) registerLabeledIfNecessary(ms *core.MetricSet, metric core.LabeledMetric, m ...metrics.Modifier) error {
+func (h *hawkularSink) registerLabeledIfNecessary(ms *core.MetricSet, metric core.LabeledMetric, m ...metrics.Modifier) (uint64, error) {
 
+	count := uint64(0)
 	var key string
 	if resourceID, found := metric.Labels[core.LabelResourceID.Key]; found {
 		key = h.idName(ms, metric.Name+separator+resourceID)
@@ -200,11 +269,13 @@ func (h *hawkularSink) registerLabeledIfNecessary(ms *core.MetricSet, metric cor
 
 	mdd, err := h.createDefinitionFromModel(ms, metric)
 	if err != nil {
-		return err
+		return 0, err
 	}
 
+	mddHash := hash(mdd)
+
 	h.regLock.RLock()
-	if _, found := h.reg[key]; !found || !reflect.DeepEqual(mdd.Tags, h.reg[key].Tags) {
+	if _, found := h.reg[key]; !found || h.reg[key] != mddHash {
 		// I'm going to release the lock to allow concurrent processing, even if that
 		// can cause dual updates (highly unlikely). The UpdateTags is idempotent in any case.
 		h.regLock.RUnlock()
@@ -214,17 +285,18 @@ func (h *hawkularSink) registerLabeledIfNecessary(ms *core.MetricSet, metric cor
 		if err := h.client.UpdateTags(heapsterTypeToHawkularType(metric.MetricType), key, mdd.Tags, m...); err != nil {
 			// Log error and don't add this key to the lookup table
 			glog.Errorf("Could not update tags: %s", err)
-			return err
+			return 0, err
 		}
 
 		h.regLock.Lock()
-		h.reg[key] = mdd
+		h.reg[key] = mddHash
 		h.regLock.Unlock()
+		count++
 	} else {
 		h.regLock.RUnlock()
 	}
 
-	return nil
+	return count, nil
 }
 
 func toBatches(m []metrics.MetricHeader, batchSize int) chan []metrics.MetricHeader {
diff --git a/metrics/sinks/hawkular/driver.go b/metrics/sinks/hawkular/driver.go
index 17452f12..1083640c 100644
--- a/metrics/sinks/hawkular/driver.go
+++ b/metrics/sinks/hawkular/driver.go
@@ -23,6 +23,7 @@ import (
 	"net/url"
 	"strconv"
 	"sync"
+	"sync/atomic"
 
 	"github.com/golang/glog"
 	"github.com/hawkular/hawkular-client-go/metrics"
@@ -60,12 +61,9 @@ func (h *hawkularSink) Register(mds []core.MetricDescriptor) error {
 
 	if !h.disablePreCaching {
 		// Fetch currently known metrics from Hawkular-Metrics and cache them
-		types := []metrics.MetricType{metrics.Gauge, metrics.Counter}
-		for _, t := range types {
-			err := h.updateDefinitions(t)
-			if err != nil {
-				return err
-			}
+		err := h.cacheDefinitions()
+		if err != nil {
+			return err
 		}
 	}
 
@@ -93,6 +91,7 @@ func (h *hawkularSink) ExportData(db *core.DataBatch) {
 		}
 
 		wg := &sync.WaitGroup{}
+		updatedTags := uint64(0)
 
 		for _, ms := range db.MetricSets {
 
@@ -123,7 +122,8 @@ func (h *hawkularSink) ExportData(db *core.DataBatch) {
 				wg.Add(1)
 				go func(ms *core.MetricSet, labeledMetric core.LabeledMetric, tenant string) {
 					defer wg.Done()
-					h.registerLabeledIfNecessary(ms, labeledMetric, metrics.Tenant(tenant))
+					c, _ := h.registerLabeledIfNecessary(ms, labeledMetric, metrics.Tenant(tenant))
+					atomic.AddUint64(&updatedTags, c)
 				}(ms, labeledMetric, tenant)
 
 				mH, err := h.pointToLabeledMetricHeader(ms, labeledMetric, db.Timestamp)
@@ -142,6 +142,7 @@ func (h *hawkularSink) ExportData(db *core.DataBatch) {
 		}
 		h.sendData(tmhs, wg) // Send to a limited channel? Only batches.. egg.
 		wg.Wait()
+		glog.V(4).Infof("ExportData updated %d tags, total size of cached tags is %d\n", updatedTags, len(h.reg))
 	}
 }
 
@@ -198,7 +199,7 @@ func NewHawkularSink(u *url.URL) (core.DataSink, error) {
 }
 
 func (h *hawkularSink) init() error {
-	h.reg = make(map[string]*metrics.MetricDefinition)
+	h.reg = make(map[string]uint64)
 	h.models = make(map[string]*metrics.MetricDefinition)
 	h.modifiers = make([]metrics.Modifier, 0)
 	h.filters = make([]Filter, 0)
diff --git a/metrics/sinks/hawkular/driver_test.go b/metrics/sinks/hawkular/driver_test.go
index 1d8cfe75..1d67d1d0 100644
--- a/metrics/sinks/hawkular/driver_test.go
+++ b/metrics/sinks/hawkular/driver_test.go
@@ -34,7 +34,7 @@ import (
 
 func dummySink() *hawkularSink {
 	return &hawkularSink{
-		reg:    make(map[string]*metrics.MetricDefinition),
+		reg:    make(map[string]uint64),
 		models: make(map[string]*metrics.MetricDefinition),
 	}
 }
@@ -295,40 +295,53 @@ func integSink(uri string) (*hawkularSink, error) {
 // Test that the tags for metric is updated..
 func TestRegister(t *testing.T) {
 	m := &sync.Mutex{}
-	definitionsCalled := make(map[string]bool)
+	// definitionsCalled := make(map[string]bool)
 	updateTagsCalled := false
+	requests := 0
 
 	s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		m.Lock()
 		defer m.Unlock()
 		w.Header().Set("Content-Type", "application/json")
 
-		if strings.Contains(r.RequestURI, "metrics?type=") {
-			typ := r.RequestURI[strings.Index(r.RequestURI, "type=")+5:]
-			definitionsCalled[typ] = true
-			if typ == "gauge" {
-				fmt.Fprintln(w, `[{ "id": "test.create.gauge.1", "tenantId": "test-heapster", "type": "gauge", "tags": { "descriptor_name": "test/metric/1" } }]`)
-			} else {
+		if strings.Contains(r.RequestURI, "tenants") {
+			fmt.Fprintln(w, `[{ "id": "test-heapster"},{"id": "fgahj-fgas-basf-gegsg" }]`)
+		} else {
+			tenant := r.Header.Get("Hawkular-Tenant")
+			if tenant != "test-heapster" {
+				requests++
 				w.WriteHeader(http.StatusNoContent)
+				return
+			}
+			if strings.Contains(r.RequestURI, "metrics?tags=descriptor_name%3A%2A") {
+				requests++
+				// typ := r.RequestURI[strings.Index(r.RequestURI, "type=")+5:]
+				// definitionsCalled[typ] = true
+				// if typ == "gauge" {
+				fmt.Fprintln(w, `[{ "id": "test.create.gauge.1", "tenantId": "test-heapster", "type": "gauge", "tags": { "descriptor_name": "test/metric/1" } }]`)
+				// } else {
+				// 	fmt.Printf("Empty\n")
+				// 	w.WriteHeader(http.StatusNoContent)
+				// }
+			} else if strings.Contains(r.RequestURI, "/tags") && r.Method == "PUT" {
+				updateTagsCalled = true
+				// assert.True(t, strings.Contains(r.RequestURI, "k1:d1"), "Tag k1 was not updated with value d1")
+				defer r.Body.Close()
+				b, err := ioutil.ReadAll(r.Body)
+				assert.NoError(t, err)
+
+				tags := make(map[string]string)
+				err = json.Unmarshal(b, &tags)
+				assert.NoError(t, err)
+
+				_, kt1 := tags["k1_description"]
+				_, dt := tags["descriptor_name"]
+
+				assert.True(t, kt1, "k1_description tag is missing")
+				assert.True(t, dt, "descriptor_name is missing")
+
+				w.WriteHeader(http.StatusOK)
 			}
-		} else if strings.Contains(r.RequestURI, "/tags") && r.Method == "PUT" {
-			updateTagsCalled = true
-			// assert.True(t, strings.Contains(r.RequestURI, "k1:d1"), "Tag k1 was not updated with value d1")
-			defer r.Body.Close()
-			b, err := ioutil.ReadAll(r.Body)
-			assert.NoError(t, err)
-
-			tags := make(map[string]string)
-			err = json.Unmarshal(b, &tags)
-			assert.NoError(t, err)
-
-			_, kt1 := tags["k1_description"]
-			_, dt := tags["descriptor_name"]
-
-			assert.True(t, kt1, "k1_description tag is missing")
-			assert.True(t, dt, "descriptor_name is missing")
-
-			w.WriteHeader(http.StatusOK)
 		}
 	}))
 	defer s.Close()
@@ -364,12 +377,13 @@ func TestRegister(t *testing.T) {
 	assert.Equal(t, 2, len(hSink.models))
 	assert.Equal(t, 1, len(hSink.reg))
 
-	assert.True(t, definitionsCalled["gauge"], "Gauge definitions were not fetched")
-	assert.True(t, definitionsCalled["counter"], "Counter definitions were not fetched")
+	// assert.True(t, definitionsCalled["gauge"], "Gauge definitions were not fetched")
+	// assert.True(t, definitionsCalled["counter"], "Counter definitions were not fetched")
 	assert.True(t, updateTagsCalled, "Updating outdated tags was not called")
+	assert.Equal(t, 2, requests)
 
 	// Try without pre caching
-	definitionsCalled = make(map[string]bool)
+	// definitionsCalled = make(map[string]bool)
 	updateTagsCalled = false
 
 	hSink, err = integSink(s.URL + "?tenant=test-heapster&disablePreCache=true")
@@ -381,8 +395,8 @@ func TestRegister(t *testing.T) {
 	assert.Equal(t, 2, len(hSink.models))
 	assert.Equal(t, 0, len(hSink.reg))
 
-	assert.False(t, definitionsCalled["gauge"], "Gauge definitions were fetched")
-	assert.False(t, definitionsCalled["counter"], "Counter definitions were fetched")
+	// assert.False(t, definitionsCalled["gauge"], "Gauge definitions were fetched")
+	// assert.False(t, definitionsCalled["counter"], "Counter definitions were fetched")
 	assert.False(t, updateTagsCalled, "Updating outdated tags was called")
 }
 
@@ -545,19 +559,7 @@ func TestTags(t *testing.T) {
 
 	assert.Equal(t, 1, tagsUpdated)
 
-	tags := hSink.reg["test-container/test-podid/test/metric/A/XYZ"].Tags
-	assert.Equal(t, 10, len(tags))
-	assert.Equal(t, "test-label", tags["projectId"])
-	assert.Equal(t, "test-container", tags[core.LabelContainerName.Key])
-	assert.Equal(t, "test-podid", tags[core.LabelPodId.Key])
-	assert.Equal(t, "test-container/test/metric/A", tags["group_id"])
-	assert.Equal(t, "test/metric/A", tags["descriptor_name"])
-	assert.Equal(t, "XYZ", tags[core.LabelResourceID.Key])
-	assert.Equal(t, "bytes", tags["units"])
-
-	assert.Equal(t, "testLabelA:testValueA,testLabelB:testValueB", tags[core.LabelLabels.Key])
-	assert.Equal(t, "testValueA", tags["labels.testLabelA"])
-	assert.Equal(t, "testValueB", tags["labels.testLabelB"])
+	assert.True(t, hSink.reg["test-container/test-podid/test/metric/A/XYZ"] > 0)
 
 	assert.Equal(t, 10, len(serverTags))
 	assert.Equal(t, "test-label", serverTags["projectId"])
diff --git a/metrics/sinks/hawkular/types.go b/metrics/sinks/hawkular/types.go
index d6a19a5c..112bd054 100644
--- a/metrics/sinks/hawkular/types.go
+++ b/metrics/sinks/hawkular/types.go
@@ -49,7 +49,7 @@ type hawkularSink struct {
 	client  *metrics.Client
 	models  map[string]*metrics.MetricDefinition // Model definitions
 	regLock sync.RWMutex
-	reg     map[string]*metrics.MetricDefinition // Real definitions
+	reg     map[string]uint64 // Hash of real definition
 
 	uri *url.URL
 
-- 
2.13.6

